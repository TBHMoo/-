第五章，线程安全的容器类，和同步工具类

【同步容器】
同步容器类包括 Vector 和 Hashtable 
这些类实现线程安全的方式是 ： 将他们的状态封装起来， 并对每个共有方法都进行同步， 使得每次只有一个线程能够访问容器的状态。

同步容器类的问题
同步容器类都是线程安全的，但是在某些情况下（并发情况下）可能需要额外的 【客户端加锁】来保护【复合操作】。  (synchronized(Vector / Hashtable))

【并发容器】
通过使用并发容器，来替代同步容器。
同步容器将所有对容器状态的访问都串行化，以实现他们的线程安全性。 

BlockingQueue 扩展了Queue  ,增加了可阻塞的插入和获取等操作。（通过 RentrantLock 实现）， 如果队列为空，那么获取元素的操作将一直阻塞，知道队列中出现
一个可用的元素。 如果有队列已满（对于有界队列来说），那么插入操作将一直阻塞，直到队列中出现可用的空间。

【ConcurrentHashMap】
a、同步容器类在执行每个操作期间都持有一个锁。（因此容器内的方法就不能互相调用，否则出现死锁）

b、ConcurrentHashMap 相对 同步容器，使用了更细粒度的锁机制，分段锁， 来实现更大程度的共享。

【CopyOnWriteArrayList】 用于替代同步 List
创建局部变量，来操作。操作完了，之后，再写回原数组。  复制原容器的时候开销比较大，适合读多写少的情况。

【阻塞队列和 生产者-消费者模式】
有界的阻塞队列，在构建高可用的应用程序时,是一种强大的资源管理工具：  它们能够抑制并防止产生过多的工作项， 使应用程序在符合过载的情况下变得更加健壮。

【信号量】
信号量可以将任何一种容器，变成有界阻塞容器。（但是现在已经有了 BlockingQueue，所以不怎么用这个信号量了。）

【闭锁、栅栏】
闭锁是一次性对象，一旦进入终止状态，就不能被重置。
闭锁用于等待事件， 栅栏用于等待线程。 

【构建高效且可伸缩的结果缓存】

方案一
  使用HashMap来保存之前计算的结果 。 compute方法将首先【检查需要的结果是否已经在缓存中】，如果存在则返回之前计算的值。 否则将计算结果缓存在 HashMap中
然后再返回。 （Cache Aside）
缺点，
  用HashMap 来做记忆功能的话， 由于 HashMap不是线程安全的，所有要对整个的compute方法加锁。每次只有一个线程可以执行 compute方法，其他线程的阻塞时间
可能会太长。

得到方案二
  使用ConcurrentHashMap代替HashMap .由于ConcurrentHashMap 是线程安全的，因此在访问底层Map时，就不需要进行同步（加锁）。因此避免了 compute方法进行
 同步时带来的串行性。
  缺点，当一个线程开启了开销非常大的计算正在进行时，其他线程并不知道计算已经开始了 。 可能会出现重复计算的情况。 这种情况最高效的情况是 其他线程要知道
“哦，等前面那个线程计算出来结果，我直接拿来用就好了 。”

方案三
  ConcurrentHashMap 中的V，用FutureTask 替换。（FutureTask 可以理解成，你下了个淘宝单，然后返回给你一个订单号，然后就等着快递上门来你出示订单号签收就好了 。 ）
内部实现是 BlockingQueue .   
缺点，
方案三几乎是完美的。但是还是存在一个因为  并发导致的问题。两个线程同时【检查需要的结果是否已经在缓存中】，得到的结果都是不在，那就两个线程分头开始计算了。
（复合操作，导致的安全性问题） 使用 ConcurrentMap 中的原子方法 putIfAbsent避免。

当缓存的是Future 而不是值时，将导致 【缓存污染问题】，就是计算被取消或者计算失败的时候。 策略是捕获到RuntimeException时，移除Future
缓存逾期问题，策略是设置缓存生效期。

 
 
