hashMap 的工作原理

你有使用过hashMap吗 ？ hashMap的特性， hashmap 没有使用 同步锁， synchronized 所以它很快，但是在多线程情况下多个线程同时达到负载因子 （0.75）重新扩容
（翻倍）时，会出现竞态条件。 会有线程安全问题。

hashMap 使用 hashing 的原理，我们使用 put(key ,value)存储对象到hashMap 中，使用 get(key) 从hashMap 中获取value.
当使用put方法传递键和值时，优先会调用键的 hashCode()方法,返回的hashCode 用于确定 bucket位置存储Entry. 

当两个对象的hashcode 相同时会发生什么，
因为有相同的hashcode ,所以会得到相同的 bucket位置，出现冲突。 hashMap处理这种冲突的方式是，追加在链表后。

如果两个键的hashCode 相同，如何获取值对象？
找到bucket 位置之后调用 keys.equals()方法去找到链表中正确的节点。



hashMap 和 hashtable 的区别
hashMap 和 HashTable都实现了Map 接口， 都可以当做Map 使用。 它们之间的区别主要有：
 
                                               HashMap                  hashTable                   concurrentHashMap
 线程安全性                                       非                       是                              是
 同步( synchronization )                          非 synchronized         是 synchronized                  
 速度（不需要同步，单线程情况下）                   快                      慢                          

1、synchronized （同步锁） 意味着一次仅仅只有一个线程可以访问更改 hashTable。 就是说任何线程要更新 hashTable时要首先获得同步锁，
其他线程必须要要等待同步锁被释放之后，才能再次获得同步锁更新HashTable
2、HashMap 也可以通过 Map  m = Collections.synchronizeMap(hashMap) 来实现同步

Java 5及以上，使用 concurrentHsahMap 替代 hashTable

函数式编程
一个输入，一个输出，数据不变性，多核高并发情况下

hashmap, 扩容过程
创建两倍大小的桶，然后把原来元素移到新桶中。


kafka 存储机制 cluster ,broker, topic ,partition ,replication, ISR in_sync_Replication, customer, producer
kafka

ES  简单使用

分布式事务
事务消息，tcc数据一致性最高




