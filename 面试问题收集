六度人和

基本的项目架构是什么样子的，然后解决过什么样的问题。

1、 java concurrent 包中的内容  以及怎么保证线程池安全关闭。 
shutdown 等待所有线程一起关闭，队列中等待执行的线程，和已经执行的线程执行完毕。 任务队列不接受新的任务线程
shutdownNow 立即关闭线程池，不接受新的线程，向执行中的线程请求中断，任务队列中等待线程，不启动。
问的应该是上面两个命令的区别 。 我回答的是，线程中等待栅栏的概念


2、 redis  中的基础数据结构，以及怎么从 list中拿到 1-100 的内容的命令是什么 
尴尬了，
String
string 是redis最基本的类型， 一个key ,一个value
一个键最大 512M

> Set name "XXXX"
> get name 

Hash
redis  hash 是一个键值对集合。
是一个string 类型的field 和 value 的映射表，适合用于存储对象
每个hash  可以存储 2^32-1 个键值对

> HMSET user:1 username redis.net.cn password redis.net.cn points 200
> HGETALL user:1
1) "username"
2) "redis.net.cn"
3) "password"
4) "redis.net.cn"
5) "points"
6) "200"


List
Redis 列表是简单的字符串列表，按照插入顺序排序。 你可以添加一个元素导列表的头部（左边）或者尾部（右边）
> lpush key reids
(interger) 1
> lpush key mongodb
(interger) 2
> lpush key rabitmq
(interger) 3
> lrange key 0 10
1) "rabitmq"
2) "mongodb"
3) "redis"

Set
redis set是string 类型的无序集合
集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)
集合中最大的成员数也是 2^32-1

 sadd 命令
 
> sadd key redis
(interger) 1
> sadd key rabitmq
(interger) 1
> sadd key rabitmq
(interger) 0

> smembers key
1) "rabitmq"
2) "redis"

zset 有序集合
zset 和 set 一样也是string 类型元素的集合，且不允许重复的成员
不同的是，每个元素都会关联一个double类型的分数。 redis 正是通过分数来为集合中的成员进行从小到大的排序。
zset 成员是唯一的，但是分数（score）却可以重复

zadd 命令
zadd key score member
  
>zadd key 0 redis
(interger) 1
> zadd key 0 mongodb
(interger) 1
> zadd key 0 rabitmq
(interger) 1
> zadd key 0 rabitmq
(interger) 0
> zrangebyscore key 0 1000
1) "redis"
2) "mongodb"
3) "rabitmq"

Hr 关心综合素质，学习能力，性格，业余生活。
技术面， 反向面试 。 照实说就行
CTO  从业务角度上描述上一家公司的系统。 然后问觉得遇到的最大的挑战，这里没有准备好。

铱云科技
笔试题
java 框架中的集合最优实现是什么？并说明原因？

blockingQueue 的最佳实现是什么。
  LinkedBlockingQueue和 ArrayBlockingQueue 是 FIFO队列。 
  PriorityBlockingQueue是一个优先队列。 
 最后一个实现BlockingQueue是 SynchronousQueue 实际上它不是一个真正的队列，因为它不会为队列中的元素维护存储空间。 于其他队列不同的是，它维护一组线程
 这些线程在等待着把元素加入或者移出队列。


threadLocal 作用和用途？

cookie 和 session 的作用和区别。 tomcat 中的  session 管理怎么实现的


AutomicInterger 是阻塞的吗？ jdk 中的实现是什么 
CAS 实现 ，不阻塞

lamda 表达式的作用？
简洁的可传递的匿名函数的一种方式，lamda只是让匿名函数可读性更强，写得更轻松。

concurrentHashMap 中解决链表过长的方式
  resize 数组，增加数组长度，来降低拉链过长的影响。

 Lock 和 synchronized 的区别。

synchronized 是悲观的锁策略，Lock （ReentrantLock） 是乐观的锁策略。
Lock  基于 CAS 实现。
基本语法上，ReentrantLock 和 synchronized 很相似，都具备线程重入特性。 
1.5之前 ReentrantLock 比 synchronized  性能好很多， 1.6  synchronized 加了很多优化，性能没什么差别。
官方也更支持 synchronized  因为 ReentrantLock 必须显式的释放。
ReentrantLock 比 synchronized 增加的高级功能
1、 等待可中断：当持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待，处理其他事情。它对执行时间非常长的同步块非常有用。
而在等待由Synchronized产生的互斥锁时，会一直阻塞，是不能被中断的
2、 ReentrantLock 可实现公平锁： 多个线程等待同一个锁时，必须按照申请锁的时间排序等待，然而非公平锁不保证锁在释放时，不保证等待线程获得锁的顺序。
ReentrantLock  默认也是非公平锁，但是可以在声明时通过构造方法 ReentrantLock (true) 来实现公平锁

3、ReentrantLock 锁和条件的关系 可以一对多。 synchronized 锁和条件的关系是一对一。 


 秒杀系统，
 
 缓存系统
 
 脱离数据库实现ID。 单数据库，应用集群。
 
 
 





