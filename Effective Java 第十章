


第66条，同步访问共享的可变数据

关键字 synchronized 可以保证在同一时刻，只有一个线程可以执行某一个方法或者代码块。 

概念理解

许多程序员把同步的概念仅仅理解为一种互斥的方式，即， 当一个对象被一个线程修改的时候，可以阻止另一个线程观察到对象内部不一致的状态。
（类似 数据库乐观锁场景）
按照这种观点，对象被创建的时候处于一致的状态， 当有方法访问它的时候，它就被锁定了。 这些方法观察到对象的状态，并且可能会引起状态转变，即把对象从一种一致的状态
转换到另一种一致的状态。

以上观点是正确的。 如果没有同步，一个线程的变化就不能被其他线程看到 。这是同步的意义

为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。 

活性失败（livenesss failure）： 因为没有同步，不能保证线程A（后台线程）看到 线程B（主线程），对【开关变量】做的修改。导致线程A 永远挂起。
1、修正活性失败有一个方式是， 给 【开关变量】实现 同步的读方法，和写方法。   线程A，用同步的读方法循环监听 【开关变量】，线程B用 同步的写方法修改【开关变量】

tips , 这里读和写，要同时实现同步，才有用。

2、另一个更为简洁的 修正活性失败的方式是， 使用 volatile 修饰 【开关变量】，这样可以【去掉】 线程A 用同步的读方法循环监听【开关变量】。 虽然 volatile 
修饰符 不执行互斥访问，但它可以保证任何一个线程在读取该域的时候都 将看到最近刚刚被写入的值。

volatile  修饰符，因为不执行互斥访问，可能会导致 [安全性失败]。

安全性失败(safety failure) :  对于不是原子性的操作 比如 i++ （增量操作符）,它分成两个部分，首先读取值，然后写回一个新值。  如果线程B ，在线程A读取旧值
和写回新值之间，读取了这个值。 那么线程A，和线程B，就会读取到同一个值。 这就是【安全性失败】

避免安全性失败的方法可以用 synchronized修饰符，但是最好还是使用 AtomicLong .


简而言之，当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。 如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。
未能同步共享可变数据会造成程序的【活性失败】(liveness failure) 和【安全性失败】（safety failure）. 这样的失败是最难调试的， 它们可能是间歇性的
且与实践相关，程序的行为在不同的VM上，可能根本不同 如果只需要线程之间互相通信，而不需要互斥，volatile 修饰符就是一种可以接受的同步形式 但是要正确地
使用它可能需要一些技巧 

###################################################################################################
我所理解的线程安全。 
 线程安全问题，其实就是共享变量的访问问题。 这里主要有两个问题。
 一/ A改变了共享变量，B不知道。（活性失败）
   解决这个活性失败，主要有两个方法  
   a. 在共享变量的读写方法上加上锁。B线程循环调用读方法 
   b. 或者实用volatile 修饰符， 因为这修饰符，可以保证任何线程在读取被volatile修饰的域的时候，都可以看到最新的一个版本
   (而且不需要循环调用读方法，具体原理不懂)
 二/ A改变了共享变量，但是改变的方法不是原子性的。使得变量有中间状态，这个中间状态被B读取了。（安全性失败）
   解决 安全性失败这个问题，主要也有两个办法
   a. 在共享变量上加上锁。 synchronized . 
   b. 使用原子性变量来做共享变量
#####################################################################################################

68条，executor 和 task 优先于线程
ExecutorService executor = Executors.newSingleThreadExecutor();
executor.execute(runnable);
executor.shutdown();

executor还可以做更多的事。

需要多个线程来处理的时候，就使用线程池。
如果是轻载的服务器，使用 Executors.newCachedThreadPool 是不错的选择。但是如果负载很重，就不合适了，在缓存的线程池中，被提交的任务没有排成队列，
而是直接交给线程执行，如果没有线程可用，就创建一个新的线程。 这个策略会在CPU被完全占用的情况下，加重CPU的负担。
因此在大负载的产品服务器中，最好使用Executors.newFixedThreadPool 。它提供了一个固定大小的线程池。




69条，并发工具优先于wait 和 notify
既然正确的使用 wait和 notify比较困难，就应该使用更高级的并发工具来代替。
java.util.concurrent 中更高级的工具分成三类： Executor Framework (任务执行框架)、并发集合(Concurrent collection)
、以及同步器 （Synchronizer） 

并发集合为标准的集合接口，提供高效的并发实现。 为了提高并发性，这些实现在内部自己管理同步。因此，并发集合中不可能排除并发活动，将它锁定没什么作用，反而会
让程序变慢。

BlockingQueue 是多数线程池的实现

维护wait 和notify  
始终应该使用wait循环模式来调用wait方法，永远不要在循环之外调用wait方法。
唤醒线程使用 notifyall， 而不是notify。










