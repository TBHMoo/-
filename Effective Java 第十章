第66条，同步访问共享的可变数据

关键字 synchronized 可以保证在同一时刻，只有一个线程可以执行某一个方法或者代码块。 

概念理解

许多程序员把同步的概念仅仅理解为一种互斥的方式，即， 当一个对象被一个线程修改的时候，可以阻止另一个线程观察到对象内部不一致的状态。
（类似 数据库乐观锁场景）
按照这种观点，对象被创建的时候处于一致的状态， 当有方法访问它的时候，它就被锁定了。 这些方法观察到对象的状态，并且可能会引起状态转变，即把对象从一种一致的状态
转换到另一种一致的状态。

以上观点是正确的。 如果没有同步，一个线程的变化就不能被其他线程看到 。这是同步的意义

为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。 

活性失败（livenesss failure）： 因为没有同步，不能保证线程A（后台线程）看到 线程B（主线程），对【开关变量】做的修改。导致线程A 永远挂起。

1、修正活性失败有一个方式是， 给 【开关变量】实现 同步的读方法，和写方法。   线程A，用同步的读方法循环监听 【开关变量】，线程B用 同步的写方法修改【开关变量】

tips , 这里读和写，要同时实现同步，才有用。

2、另一个更为简洁的 修正活性失败的方式是， 使用 volatile 修饰 【开关变量】，这样可以【去掉】 线程A 用同步的读防范循环监听【开关变量】。 虽然 volatile 
修饰符 不执行互斥访问，但它可以保证任何一个线程在读取该域的时候都 将看到最近刚刚被写入的值。

volatile  修饰符，因为不执行互斥访问，可能会导致 [安全性失败]。

安全性失败(safety failure) :  对于不是原子性的操作 比如 ++ （增量操作符）,它分成两个部分，首先读取值，然后写回一个新值。  如果线程B ，在线程A读取旧值
和写回新值之间，读取了这个值。 那么线程A，和线程B，就会读取到同一个值。 这就是【安全性失败】

避免安全性失败的方法可以用 synchronized修饰符，但是最好还是使用 AtomicLong .


