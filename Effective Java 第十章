第66条，同步访问共享的可变数据

关键字 synchronized 可以保证在同一时刻，只有一个线程可以执行某一个方法或者代码块。 

概念理解

许多程序员把同步的概念仅仅理解为一种互斥的方式，即， 当一个对象被一个线程修改的时候，可以阻止另一个线程观察到对象内部不一致的状态。
（类似 数据库乐观锁场景）
按照这种观点，对象被创建的时候处于一致的状态， 当有方法访问它的时候，它就被锁定了。 这些方法观察到对象的状态，并且可能会引起状态转变，即把对象从一种一致的状态
转换到另一种一致的状态。

以上观点是正确的。 如果没有同步，一个线程的变化就不能被其他线程看到 。这是同步的意义

为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。 

活性失败（livenesss failure）： 因为没有同步，不能保证线程A（后台线程）看到 线程B（主线程），对【开关变量】做的修改。导致线程A 永远挂起。

1、修正活性失败有一个方式是， 给 【开关变量】实现 同步的读方法，和写方法。   线程A，用同步的读方法循环监听 【开关变量】，线程B用 同步的写方法修改【开关变量】

tips , 这里读和写，要同时实现同步，才有用。

2、另一个更为简洁的 修正活性失败的方式是， 使用 volatile 修饰 【开关变量】，这样可以【去掉】 线程A 用同步的读防范循环监听【开关变量】。 虽然 volatile 
修饰符 不执行互斥访问，但它可以保证任何一个线程在读取该域的时候都 将看到最近刚刚被写入的值。

volatile  修饰符，因为不执行互斥访问，可能会导致 [安全性失败]。

安全性失败(safety failure) :  对于不是原子性的操作 比如 ++ （增量操作符）,它分成两个部分，首先读取值，然后写回一个新值。  如果线程B ，在线程A读取旧值
和写回新值之间，读取了这个值。 那么线程A，和线程B，就会读取到同一个值。 这就是【安全性失败】

避免安全性失败的方法可以用 synchronized修饰符，但是最好还是使用 AtomicLong .


简而言之，当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。 如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。
未能同步共享可变数据会造成程序的【活性失败】(liveness failure) 和【安全性失败】（safety failure）. 这样的失败是最难调试的， 它们可能是间歇性的
且与实践相关，程序的行为在不同的VM上，可能根本不同 如果只需要线程之间互相通信，而不需要互斥，volatile 修饰符就是一种可以接受的同步形式 但是要正确地
使用它可能需要一些技巧 

68条，executor 和 task 优先于线程
ExecutorService executor = Executors.newSingleThreadExecutor();
executor.execute(runnable);
executor.shutdown();

executor还可以做更多的事。

需要多个线程来处理的时候，就使用线程池。
如果是轻载的服务器，使用 Executors.newCachedThreadPool 是不错的选择。但是如果负载很重，就不合适了，在缓存的线程池中，被提交的任务没有排成队列，
而是直接交给线程执行，如果没有线程可用，就创建一个新的线程。 这个策略会在CPU被完全占用的情况下，加重CPU的负担。
因此在大负载的产品服务器中，最好使用Executors.newFixedThreadPool 。它提供了一个固定大小的线程池。








