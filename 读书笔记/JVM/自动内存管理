# Java自动内存管理
```
Java 与 C++ 之间有一堵由内存动态分配和垃圾回收技术所围成的高墙，墙外的人想进来，墙里的人想出去。
对于从事C和C++程序开发的人员来说，他们既是拥有最高权力的皇帝，也是最底层的劳动人民。拥有每一个对象的所有权，又承担着每一个对象从开始到结束的维护工作。
对于从事Java程序开发的人员来说，在虚拟机的自动内存管理机制帮助下，不在需要为每一个new 操作去写配对的delete/free 代码，而且不容易出现内存泄漏和内存溢出问题。
看起来一切都很美好，但是出现了内存泄漏和溢出，不了解虚拟机是如何使用内存的，那么将无法解决这个问题。
```

## 运行时数据区域
JVM Java 虚拟机在执行Java 程序时会把它所管理的内存，分为若干个区域。
这些区域有各自的用途，以及创建和销毁时间。 

## 有的区域随着虚拟机启动而存在（所有线程一起共享） OutOfMemoryError
```
`Java 堆`，随着虚拟机启动而创建，一般来说是Java 虚拟机中最大的内存区域。用来存储对象实例。GC主要就发生在这个区域
（-Xmx, -Xms）
```
```
方法区， 和堆一样是各个线程共享的区域，用于存储已被虚拟机加载的类信息，常量，静态变量等
运行时常量池，是方法区的一部分，运行期间，可以新加入常量到常量池 （String 类的 intern() 方法） 
```

### GC原理
#### 哪些内存需要回收？
#### 何时回收？
#### 如何回收？

```
    哪些对象需要回收？
    已死对象需要回收。 如何判断对象生死
    1.引用计数法 为每个对象计数引用次数，引用次数为0时，可以回收。 问题是 无法解决循环引用但无循环外对象可以访问的问题
    2.根搜法 图论 ，从根节点访问不到的对象 会被标记，缓刑处理 （根节点为栈中的引用，方法区中的引用）  
    对于对象的生或死，定义过于单一，于是引入引用分级。描述的是这样一种对象，如果内存够的话，就算根搜法对象不可达，我也不希望回收，还有更弱的存在
    弱引用遇到GC就会被回收，软引用只会在OOM之前的那次GC被回收
    
tips:

从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期，进而控制内存。
这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。

1、强引用（StrongReference）
      强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它
2、软引用（SoftReference）
      如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。
      只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
3、弱引用（WeakReference）
      弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，
      一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
4、虚引用（PhantomReference）
     “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，
     那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
    虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。
    当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。
```

```
   何时回收？
   GC的触发机制 内存不够时 ，暂未深入了解
```
```
   如何回收？
   GC算法， 
   标记-清除算法，标记所有需要回收的对象，标记完成后统一回收被标记对象。
   有两个问题 1 标记和回收的效率都不高，2 会照成空间碎片
   为了解决效率问题， 复制算法出现
   复制算法将可用内存分成相同的两块，每次只使用其中一块，当这一块内存用完，就将还活着的对象复制到另一块，然后再把已使用过的内存一次清理掉。
   现在的商业虚拟机使用的都是复制算法来收集新生代，IBM的研究表明，新生代中的对象98%是朝生夕死的，所以不需要按1:1 的比例来分配内存区域，而是
   将内存划分成3块，一块较大的Eden区，两块较小的Survivor区，每次只使用Eden 区和其中一块Survivor区，回收时将活着的对象放到另一个Survivor区，
   然后清理掉前面使用的Eden 和一块Survivor区
   
   标记-整理算法
   复制算法在对象存活率比较高的时候，因为要执行多次的复制，效率会变低。根据老年代的特点，标记过程和之前的标记-清除算法一致，只是标记完成后从清理变成
   整理，将活着的对象都向一端移动，然后清理端边界外的内存。
   
   分代收集算法
   当前商业虚拟机的垃圾收集都采用分代收集算法， 这种算法并没有什么新的思想。只是根据对象的存活周期，将JAVA堆分成了新生代和老年代。这样就可以根据不同
   年代的特征，去选择不同的收集算法。（新生代-复制 老年代 标记-整理 标记-清除）
```



## 有的区域随着用户线程的启动和结束而创建和销毁。（线程之间隔离） StackOverFlowError
```
程序计数器 记录着用户线程执行到哪  每个线程单独一个计数器
```
```
Java 虚拟机栈 每一个方法被调用的同时，都会创建一个栈帧，用于存储局部变量表，操作栈，动态链接，方法出口等。每一个方法被调用到执行完成的过程，就对应着一个
栈帧在虚拟机栈中的入栈和出栈的过程。
本地方法栈 作用类似虚拟机栈，只是对应的是Native 方法，非java语言方法。
```

